# -*- coding: utf-8 -*-
"""Animal-EDS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uP7x5_4CZ0cI2eXKxxsoNqKCJxcge4Hr

Animal tracking data helps us understand how individuals and populations move within local areas, migrate across oceans and continents and evolve across generations. This information is being used to address environmental challenges such as climate and land use change, biodiversity loss, invasive species, wildlife trafficking and the spread of infectious diseases.

Since the twentieth century, improved communication systems, shrinking battery sizes and other technological developments have led to a range of methods for tracking animals. Scientists have been systematically tracking individual animal movements since around 1900, when the first bird ringing (also known as bird banding) schemes were started. In the late 1950s, researchers began using radio transmitters to track wildlife. In the late 1970s, the Argos satellite system provided a new method for tracking animals globally. And in the early 1990s, the global positioning system (GPS) began to provide the potential to obtain high-resolution tracking data.

Choosing a tracking method involves trade-offs between size, price, and amount and ease of data collection. The ideal tag would be lightweight enough to be safely carried by the animal, cheap enough to put on many individuals, and able to transmit high-resolution data remotely so that the animal did not need to be captured again. In reality, a scientist must choose the best available method based on the size and movement patterns of the study animal, the study budget and the research questions they want to address.
"""

import numpy as np
import pandas as pd
import folium
from folium.map import Icon

df=pd.read_csv('migration_original.csv')

df.head()

df.columns

del df['manually-marked-outlier']

del df['visible']

del df['sensor-type']

del df['ECMWF Interim Full Daily Invariant Low Vegetation Cover']
del df['NCEP NARR SFC Vegetation at Surface']
del df['ECMWF Interim Full Daily Invariant High Vegetation Cover']

df.tail()

df.describe()

df.info()

df.shape

# Define a function to detect outliers using IQR
def detect_outliers_IQR(data):
    Q1 = data.quantile(0.25)
    Q3 = data.quantile(0.75)
    IQR = Q3 - Q1
    lower_bound = Q1 - 1.5 * IQR
    upper_bound = Q3 + 1.5 * IQR
    outliers = ((data < lower_bound) | (data > upper_bound))
    return outliers

# Select the numerical features for scaling and outlier removal
numerical_features = df.select_dtypes(include=[np.number]).columns

# Detect and remove outliers from each numerical feature in the original DataFrame
for feature in numerical_features:
    outliers = detect_outliers_IQR(df[feature])
    df = df[~outliers]

# Check the cleaned DataFrame
print(df.info())

pip install cartopy

# Commented out IPython magic to ensure Python compatibility.
import matplotlib.pyplot as plt
# %matplotlib inline

import cartopy.crs as ccrs
import cartopy.feature as cfeature

# Create a GeoAxes in the orthographic projection
fig, ax = plt.subplots(figsize=(10, 10), subplot_kw={'projection': ccrs.Orthographic(central_longitude=0, central_latitude=90)})

# Set the extent of the map
ax.set_extent([-180, 180, 20, 90], crs=ccrs.PlateCarree())

# Draw map features
ax.add_feature(cfeature.LAND, facecolor='coral')
ax.add_feature(cfeature.OCEAN, facecolor='aqua')
ax.add_feature(cfeature.COASTLINE)

# Plot points
for i in range(0, 10000000, 1000000):
    ax.plot(i, i, marker='o', color='k', transform=ccrs.PlateCarree())

plt.show()

pip install geopy

import cartopy.crs as ccrs
import cartopy.feature as cfeature
from geopy.distance import great_circle

df = df.dropna(subset=['location-lat', 'location-long'])
df = df.replace([np.inf, -np.inf], np.nan).dropna(subset=['location-lat', 'location-long'])

print(df['location-lat'].isna().sum())
print(df['location-long'].isna().sum())

print(np.isinf(df['location-lat']).sum())
print(np.isinf(df['location-long']).sum())

import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.feature as cfeature
from geopy.distance import great_circle
import numpy as np


# Remove NaN and Inf values from the DataFrame
df = df.dropna(subset=['location-lat', 'location-long'])
df = df.replace([np.inf, -np.inf], np.nan).dropna(subset=['location-lat', 'location-long'])

# Calculate the extent of the map after removing NaN and Inf values
LowerLattitude = df['location-lat'].min()
UpperLattitude = df['location-lat'].max()
LowerLontitude = df['location-long'].min()
UpperLontitude = df['location-long'].max()

plt.figure(figsize=(20, 10))
ax = plt.axes(projection=ccrs.PlateCarree())
ax.set_extent([LowerLontitude, UpperLontitude, LowerLattitude, UpperLattitude])

ax.add_feature(cfeature.LAND, facecolor='coral')
ax.add_feature(cfeature.OCEAN, facecolor='aqua')
ax.add_feature(cfeature.COASTLINE)

# Plot points for all animals
ax.plot(df['location-long'], df['location-lat'], 'ro', markersize=1, alpha=.3, transform=ccrs.PlateCarree())

# Plot points for a specific animal
longs = df[df['individual-local-identifier'] == '91732A']['location-long']
lat = df[df['individual-local-identifier'] == '91732A']['location-lat']
ax.plot(longs, lat, 'ro', markersize=1, alpha=.8, transform=ccrs.PlateCarree())

plt.show()

# Calculate the total distance travelled by the specific animal
distance_travelled = 0
for i in range(len(longs) - 1):
    point1 = (lat.iloc[i], longs.iloc[i])
    point2 = (lat.iloc[i + 1], longs.iloc[i + 1])
    distance_travelled += great_circle(point1, point2).km

print(f"Total distance travelled by animal '91732A': {distance_travelled} km")

import matplotlib.pyplot as plt

# Convert timestamp to datetime
df['timestamp'] = pd.to_datetime(df['timestamp'])

# Plot time series of location coordinates
plt.figure(figsize=(12, 6))
plt.plot(df['timestamp'], df['location-lat'], label='Latitude', color='blue')
plt.plot(df['timestamp'], df['location-long'], label='Longitude', color='green')
plt.xlabel('Timestamp')
plt.ylabel('Coordinates')
plt.title('Time Series of Location Coordinates')
plt.legend()
plt.show()

import seaborn as sns

# Plot histogram of sensor types
plt.figure(figsize=(10, 6))
sns.countplot(data=df, x='sensor-type')
plt.xlabel('Sensor Type')
plt.ylabel('Count')
plt.title('Histogram of Sensor Types')
plt.xticks(rotation=45)
plt.show()

# Plot boxplot of individual taxon canonical name
plt.figure(figsize=(10, 6))
sns.boxplot(data=df, x='individual-taxon-canonical-name', y='location-lat')
plt.xlabel('Individual Taxon Canonical Name')
plt.ylabel('Latitude')
plt.title('Boxplot of Individual Taxon Canonical Name vs. Latitude')
plt.xticks(rotation=45)
plt.show()

# Plot scatter plot of location coordinates
plt.figure(figsize=(10, 6))
plt.scatter(df['location-long'], df['location-lat'], alpha=0.5)
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Scatter Plot of Location Coordinates')
plt.show()

# Select relevant columns for pairplot
df_pairplot = df[['location-long', 'location-lat', 'sensor-type']]

# Plot pairplot
plt.figure(figsize=(10, 6))
sns.pairplot(df_pairplot, hue='sensor-type', markers=["o", "s", "D"], diag_kind='kde')
plt.title('Pairplot of Location Coordinates and Sensor Types')
plt.show()

plt.figure(figsize=(10, 6))
df['individual-taxon-canonical-name'].value_counts().plot(kind='bar')
plt.title('Distribution of Animal Species')
plt.xlabel('Species')
plt.ylabel('Count')
plt.xticks(rotation=45)
plt.show()

import seaborn as sns

# Select only numeric columns
numeric_df = df.select_dtypes(include=['float64', 'int64'])

# Compute correlation matrix
corr_matrix = numeric_df.corr()

# Plot heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(corr_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Heatmap')
plt.show()

sns.pairplot(df[['location-long', 'location-lat']])
plt.title('Pairplot of Numerical Features')
plt.show()

import plotly.express as px

# Create a scatter plot
fig = px.scatter(df, x='location-long', y='location-lat', title='Animal Tracking')

# Show the plot
fig.show()

# Scatter plot with different attributes
fig1 = px.scatter(df, x='location-long', y='location-lat', color='individual-taxon-canonical-name', title='Animal Tracking - Taxon Name',
                  labels={'location-long': 'Longitude', 'location-lat': 'Latitude', 'individual-taxon-canonical-name': 'Taxon Name'})
fig1.update_layout(plot_bgcolor='black', paper_bgcolor='black', font=dict(color='white'))


# Show the plots
fig1.show()

# Scatter plot with different attributes
fig2 = px.scatter(df, x='location-long', y='location-lat', color='study-name', title='Animal Tracking - Study Name',
                  labels={'location-long': 'Longitude', 'location-lat': 'Latitude', 'study-name': 'Study Name'})
fig2.update_layout(plot_bgcolor='black', paper_bgcolor='black', font=dict(color='white'))

fig2.show()

import folium
from folium.plugins import MarkerCluster

# Create a Folium map centered around the mean latitude and longitude
map_center = [df['location-lat'].mean(), df['location-long'].mean()]
m = folium.Map(location=map_center, zoom_start=10)

# Create a MarkerCluster layer
marker_cluster = MarkerCluster().add_to(m)

# Add markers for each data point in the dataset
for idx, row in df.iterrows():
    folium.Marker([row['location-lat'], row['location-long']], popup=row['individual-taxon-canonical-name']).add_to(marker_cluster)

# Save the map as an HTML file
m.save('folium_map.html')

df['year'] = df['timestamp'].dt.year
df['month'] = df['timestamp'].dt.month
df['day'] = df['timestamp'].dt.day
df['hour'] = df['timestamp'].dt.hour

df['hour_sin'] = np.sin(2 * np.pi * df['timestamp'].dt.hour / 24)
df['hour_cos'] = np.cos(2 * np.pi * df['timestamp'].dt.hour / 24)

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
df.groupby('hour').size().plot(kind='bar', color='skyblue')
plt.title('Hourly Distribution of Events')
plt.xlabel('Hour of Day')
plt.ylabel('Event Count')
plt.xticks(rotation=0)
plt.show()

plt.figure(figsize=(10, 6))
df.groupby('month').size().plot(kind='bar', color='lightgreen')
plt.title('Monthly Distribution of Events')
plt.xlabel('Month')
plt.ylabel('Event Count')
plt.xticks(rotation=0)
plt.show()

plt.figure(figsize=(10, 6))
df.groupby('year').size().plot(kind='bar', color='salmon')
plt.title('Event Count by Year')
plt.xlabel('Year')
plt.ylabel('Event Count')
plt.xticks(rotation=0)
plt.show()

plt.figure(figsize=(10, 6))
plt.plot(df['hour'], df['hour_sin'], marker='o', linestyle='-')
plt.title('Hourly Distribution of Events (Sinusoidal)')
plt.xlabel('Hour of Day')
plt.ylabel('Sinusoidal Value')
plt.xticks(range(0, 24))
plt.grid(True)
plt.show()

import matplotlib.pyplot as plt

# Set the timestamp column as the index
df['timestamp'] = pd.to_datetime(df['timestamp'])
df.set_index('timestamp', inplace=True)

# Resample the data to get event counts per day
event_count_per_day = df.resample('D').size()

# Plot the event count over time
plt.figure(figsize=(12, 6))
event_count_per_day.plot(color='purple')
plt.title('Event Count Over Time')
plt.xlabel('Date')
plt.ylabel('Event Count')
plt.grid(True)
plt.show()

import plotly.express as px

# Plot the scatter plot for time features with black background and green dots
fig = px.scatter(df, x='hour_sin', y='hour_cos', color='visible.1')
fig.update_traces(marker=dict(color='green'), selector=dict(mode='markers'))
fig.update_layout(plot_bgcolor='black')
fig.show()

import plotly.express as px

# Create a scatter plot for taxonomical name coordinates at a certain hour, month, or year
fig = px.scatter(df, x='location-long', y='location-lat', color='hour',
                 hover_name='individual-taxon-canonical-name',
                 animation_frame='year', animation_group='individual-taxon-canonical-name',
                 title='Taxonomical Name Coordinates by Hour and Year')
fig.update_layout(title_x=0.5)
fig.show()

import matplotlib.pyplot as plt
import seaborn as sns


# Set the style for the plot
sns.set(style="whitegrid")

# Create a scatter plot with hue for the hour of the day
plt.figure(figsize=(10, 8))
scatter = sns.scatterplot(x='location-long', y='location-lat', hue='hour', palette='viridis',
                          data=df, legend='full', s=50)

# Add labels and title
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Taxonomical Names by Hour of the Day')

# Add taxonomical names as annotations
for i, name in enumerate(df['individual-taxon-canonical-name']):
    plt.text(df['location-long'].iloc[i]+0.01, df['location-lat'].iloc[i]+0.01, name,
             horizontalalignment='left', size='small', color='black', weight='semibold')

# Show the plot
plt.show()

# Aggregate the counts by year, month, and hour
time_counts = df.groupby(['year', 'month', 'hour']).size().reset_index(name='counts')

# Create a line chart for observation counts over time
plt.figure(figsize=(12, 6))
for hour in time_counts['hour'].unique():
    subset = time_counts[time_counts['hour'] == hour]
    plt.plot(subset['year'] + (subset['month'] - 1) / 12.0, subset['counts'], label=f'Hour {hour}')

# Add labels and title
plt.xlabel('Year')
plt.ylabel('Number of Observations')
plt.title('Observation Counts Over Time by Hour')
plt.legend()

# Show the plot
plt.show()

import plotly.express as px

# Create an interactive scatter plot with Plotly
fig = px.scatter(df, x='location-long', y='location-lat', color='hour',
                 hover_name='individual-taxon-canonical-name',
                 title='Interactive Taxonomical Observations by Hour of the Day')
fig.show()

# Pivot the data to get the counts by month and hour
pivot_table = df.pivot_table(values='event-id', index='month', columns='hour', aggfunc='count')

# Create a heatmap
plt.figure(figsize=(10, 8))
sns.heatmap(pivot_table, cmap='YlGnBu')

# Add labels and title
plt.xlabel('Hour of the Day')
plt.ylabel('Month')
plt.title('Observation Counts by Month and Hour')

# Show the plot
plt.show()

# Count the number of observations for each hour and taxonomical name
hour_counts = df.groupby(['hour', 'individual-taxon-canonical-name']).size().reset_index(name='counts')

# Create a bar chart for each taxonomical name by hour
plt.figure(figsize=(12, 6))
for name in hour_counts['individual-taxon-canonical-name'].unique():
    subset = hour_counts[hour_counts['individual-taxon-canonical-name'] == name]
    plt.bar(subset['hour'], subset['counts'], alpha=0.5, label=name)

# Add labels and title
plt.xlabel('Hour of the Day')
plt.ylabel('Number of Observations')
plt.title('Taxonomical Names by Hour of the Day')
plt.legend(title='Taxonomical Names', bbox_to_anchor=(1.05, 1), loc='upper left')

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set the style for the plot
sns.set(style="whitegrid")

# Create a scatter plot with hue for the hour of the day
plt.figure(figsize=(10, 8))
scatter = sns.scatterplot(x='location-long', y='location-lat', hue='hour', palette='viridis',
                          data=df, legend='full', s=50)

# Add labels and title
plt.xlabel('Longitude')
plt.ylabel('Latitude')
plt.title('Taxonomical Observations by Hour of the Day')

# Show the plot
plt.show()

import matplotlib.pyplot as plt
import seaborn as sns

# Set the style for the plot
sns.set(style="whitegrid")

# Create a scatter plot with hue for the hour of the day
plt.figure(figsize=(12, 10))  # Increased figure size
scatter = sns.scatterplot(x='location-long', y='location-lat', hue='hour', palette='viridis_r', alpha=0.7,
                          data=df, legend='full', s=50)

# Add labels and title
plt.xlabel('Longitude', fontsize=14)
plt.ylabel('Latitude', fontsize=14)
plt.title('Taxonomical Names by Hour of the Day', fontsize=16)

# Increase the size of the legend text
plt.legend(title='Hour of the Day', title_fontsize='14', fontsize='12')

# Show the plot
plt.show()